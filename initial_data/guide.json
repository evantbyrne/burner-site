[{"id":"1","order":"3","guidecategory":"1","title":"Installation","url":"install","content":"<p>Getting Burner up and running on a development machine is a pretty quick process. The very first step is to configure your basic site settings, which are located in <code>app\/config\/development\/config.php<\/code>. The most important config option to pay attention to at this time is the <code>base_url<\/code>, which should be set to the root URL of your website:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">\/\/ Application's Base URL (including trailing slash)\r\nConfig::set('base_url', 'localhost:8888\/burner-site\/');<\/pre>\r\n\r\n<p>Next, the MySQL settings need to be configured. These can be found in <code>app\/config\/development\/db.php<\/code>:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">Config::set('database',array(\r\n\t\r\n\t'host'=&gt;'localhost',\r\n\t'username'=&gt;'root',\r\n\t'password'=&gt;'root',\r\n\t'database'=&gt;'burner_site'\r\n\t\r\n));<\/pre>\r\n\r\n<p>Lastly, run the following commands from the terminal. This will generate unique hash settings for authentication; create the MySQL tables for the user, group, and membership models; create the admin group if it doesn't exist; and it will prompt you to create an admin user.<\/p>\r\n\r\n<pre class=\"prettyprint\">cd path\/to\/directory\/containing\/index.php\r\nphp index.php generate_hash_secret development\r\nphp index.php install<\/pre>\r\n\r\n<p>For more information on these commands, please either see their respective documentation pages or use the help command like so:<\/p>\r\n\r\n<pre class=\"prettyprint\">php index.php help generate_hash_secret\r\nphp index.php help install<\/pre>\r\n<hr\/>\r\n\r\n<h3>HTTPS<\/h3>\r\n<p>To make Burner CMS use HTTPS URLs by default, find the <code>https<\/code> configuration option in <code>app\/config\/development\/config.php<\/code> and change the value to <code>true<\/code>.<\/p>\r\n<pre class=\"prettyprint lang-php\">\/\/ Use HTTPS URLs?\r\nConfig::set('https', true);<\/pre>"},{"id":"2","order":"5","guidecategory":"1","title":"Models Overview","url":"models","content":"<p>Models make up the heart and soul of every Burner application. In Burner, models are used to interface with the database in an object-oriented fashion. Each model represents a single table in the database. Additionally, models tell Burner how data can be managed in the admin control panel.<\/p>\r\n\r\n<hr\/>\r\n\r\n<h3>Defining Models<\/h3>\r\n<p>To define a new model, create a PHP file in the <strong>app\/model<\/strong> folder with the name of the model that you want (all lowercase file name). For the sake of example, we'll create a model named <strong>Article<\/strong>, so the file will be <strong>app\/model\/article.php<\/strong>. Now create a class in this file which extends the base model:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">&lt;?php\r\n\r\nnamespace App\\Model;\r\n\r\nclass Article extends \\Core\\Model\\Base {\r\n\r\n}<\/pre>\r\n\r\n<p>The next step is to define columns for the model. This is done by adding properties to the class, which have doc comments that define their data types by using the special <strong>@option<\/strong> syntax.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">class Article extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Varchar\r\n     * @option length = 100\r\n     * @option required = The title field is required.\r\n     *\/\r\n    public $title;\r\n\r\n    \/**\r\n     * @option type = Text\r\n     * @option required = The content field is required.\r\n     *\/\r\n    public $content;\r\n\r\n}<\/pre>\r\n\r\n<p>After the model is defined, the table can be created in the database by using the <strong>create<\/strong> command from the terminal.<\/p>\r\n<pre class=\"prettyprint\">php index.php create article<\/pre>\r\n\r\n<p>If you would like to see the table creation SQL before actually creating it, then use the <strong>sql<\/strong> command.<\/p>\r\n<pre class=\"prettyprint\">php index.php sql article<\/pre>\r\n\r\n<p>Model tables can also be dropped by using the <strong>drop<\/strong> command.<\/p>\r\n<pre class=\"prettyprint\">php index.php drop article<\/pre>\r\n\r\n<p>There are more terminal commands available for use as well, so be sure to check out the CLI Commands section of the guides documentation.<\/p>\r\n\r\n<hr\/>\r\n\r\n<h3>Enabling For The Admin<\/h3>\r\n<p>Making it so that model data can be managed in the admin is just a matter of adding the model name to the correct configuration option. To add the article model, just open up <strong>app\/config\/development\/config.php<\/strong> and change the appropriate option, like so:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">Config::set('admin_models', array(\r\n\t'Users' =&gt; array('user', 'group', 'membership'),\r\n\t'Some Category' =&gt; array('article')\r\n));<\/pre>\r\n\r\n<hr\/>\r\n\r\n<h3>Model API<\/h3>\r\n<p>Once a model has been created, it can be used from within any part of your application in order to query the database. The API covers everything from table creation to complex select queries.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">\/\/ Select\r\n$results = \\App\\Model\\Article::select()->where('title', '=', 'Awesome')->fetch();\r\n\r\n\/\/ Insert\r\n$a = new \\App\\Model\\Article();\r\n$a->title = 'Cool';\r\n$a->content = 'Yup.';\r\n$id = $a->save();\r\n\r\n\/\/ Drop table\r\n\\App\\Model\\Article::drop_table();<\/pre>\r\n\r\n<p>For more complete examples please refer to the remainder of the model guides.<\/p>"},{"id":"3","order":"1","guidecategory":"4","title":"CLI Overview","url":"cli","content":"<p>Burner CMS comes bundled with a collection of useful commands, which are runnable via the terminal. It's also easy to define your own custom terminal commands. Burner's bundled commands can be found in the <code>burner\/command<\/code> directory.<\/p>\r\n<hr\/>\r\n\r\n<h3>Defining Commands<\/h3>\r\n<p>Commands are just PHP classes which have the <code>help()<\/code> and <code>run()<\/code> methods. To create a command, just make a new PHP file in the <code>app\/command<\/code> directory. The file name should be exactly the same as the class name, except all lowercase. So for a command with the class name of <code>Foo<\/code>, the file path (relative to index.php) would be <code>app\/command\/foo.php<\/code>. The content of this file might look something like this:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">&lt;?php\r\n\r\nnamespace App\\Command;\r\n\r\nclass Foo {\r\n\r\n    public function help() {\r\n        echo \"Useful information about the command.\\n\\n\";\r\n    }\r\n\r\n    public function run($name) {\r\n        echo \"Hello, $name!\\n\\n\";\r\n    }\r\n\r\n}<\/pre>\r\n\r\n<p>This command could then be run from the terminal like so:<\/p>\r\n<pre class=\"prettyprint lang-xml\">php index.php foo Bob<\/pre>\r\n\r\n<p>Which would output the following:<\/p>\r\n<pre class=\"prettyprint lang-xml\">Hello, Bob!\\n\\n<\/pre>\r\n\r\n<p>And the help message could be displayed by running the help command:<\/p>\r\n<pre class=\"prettyprint lang-xml\">php index.php help foo<\/pre>"},{"id":"4","order":"2","guidecategory":"4","title":"CLI Help Command","url":"cli-help","content":"<p>The help command displays (hopefully) helpful documentation for other commands. Example usage and output:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">php index.php help sql<\/pre>\r\n\r\n<pre class=\"prettyprint lang-xml\">sql &lt;model&gt; [, &lt;model&gt;, ... ]\r\n\r\nDescription:\r\n    Generates SQL for a given model(s). Requires database connection.<\/pre>"},{"id":"5","order":"9","guidecategory":"4","title":"CLI SQL Command","url":"cli-sql","content":"<p>The SQL command outputs MySQL <code>CREATE TABLE<\/code> syntax for the given models. Useful for seeing what MySQL Burner's ORM is generating under the hood. Example usage and output:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">php index.php sql user<\/pre>\r\n\r\n<pre class=\"prettyprint lang-sql\">CREATE TABLE `user`(\r\n`id` INT NOT NULL AUTO_INCREMENT,\r\nPRIMARY KEY(`id`),\r\n`email` VARCHAR(100),\r\n`password` CHAR(128)\r\n) ENGINE = InnoDB;<\/pre>"},{"id":"6","order":"7","guidecategory":"4","title":"CLI Create Command","url":"cli-create","content":"<p>The create command generates and runs MySQL <code>CREATE TABLE<\/code> syntax for the given models. Example usage:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">php index.php create user<\/pre>"},{"id":"7","order":"8","guidecategory":"4","title":"CLI Drop Command","url":"cli-drop","content":"<p>The drop command generates and runs MySQL <code>DROP TABLE<\/code> syntax for the given models. Example usage:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">php index.php drop user<\/pre>"},{"id":"8","order":"10","guidecategory":"4","title":"CLI Sync Command","url":"cli-sync","content":"<p>The sync command drops and then recreates the MySQL tables for the given models. Useful for making quick model changes in development environments. Example usage:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">php index.php sync user<\/pre>\r\n\r\n<p><strong>Note:<\/strong> MySQL tables are dropped and then recreated when running this command. They are not altered. This means that any data stored in the given models will be lost.<\/p>"},{"id":"9","order":"4","guidecategory":"4","title":"CLI Install Command","url":"cli-install","content":"<p>Creates MySQL tables for the User, Group, and Membership models if they don't already exist; creates 'admin' group if it doesn't exist; and prompts you to create an admin user. Example usage:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">php index.php install<\/pre>\r\n\r\n<p><strong>Note:<\/strong> Only works with MultipleGroups auth plugin (which is the default). Running after insert error shouldn't mess up existing data.<\/p>"},{"id":"10","order":"3","guidecategory":"4","title":"CLI Generate Hash Command","url":"cli-generate-hash","content":"<p>Creates a random string and sets it to 'hash_secret' configuration option, which is used for hashing passwords. Example usage:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">php index.php generate_hash_secret development<\/pre>\r\n\r\n<p><strong>Note:<\/strong> This will overwrite the app\/config\/&lt;config&gt;\/hash.php file.<\/p>"},{"id":"11","order":"12","guidecategory":"4","title":"CLI Export JSON Command","url":"cli-export-json","content":"<p>Exports the contents of the MySQL table for a model to a JSON formatted file. Example usage:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">php index.php export_json user outfile.json<\/pre>"},{"id":"12","order":"13","guidecategory":"4","title":"CLI Import JSON Command","url":"cli-import-json","content":"<p>Imports the contents of a JSON formatted file to the MySQL table of the specified model. Example usage:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">php index.php import_json user infile.json<\/pre>"},{"id":"13","order":"11","guidecategory":"4","title":"CLI Alter Add Command","url":"cli-alter-add","content":"<p>Adds a column to the MySQL table of the specified model. Column must be defined in the model for this to work.<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">php index.php alter_add user some_unsynced_column<\/pre>\r\n\r\n<p><strong>Note:<\/strong> Always make backups of important data before running this command!<\/p>"},{"id":"14","order":"5","guidecategory":"4","title":"CLI Create Controller Command","url":"cli-create-controller","content":"<p>Creates a controller file with the specified controller class name. Example usage:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">php index.php create_controller Foo<\/pre>\r\n\r\n<p>This would create a controller file at <code>app\/controller\/foo.php<\/code> with the following content:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">&lt;?php\r\n\r\nnamespace App\\Controller;\r\n\r\nclass Foo extends \\Core\\Controller\\Base {\r\n\r\n}<\/pre>\r\n\r\n<p><strong>Note:<\/strong> Make sure to use the correct capitalization for the class name while using this command. For example, <code>bar<\/code> would be incorrect, but <code>Bar<\/code> would be fine.<\/p>"},{"id":"15","order":"6","guidecategory":"4","title":"CLI Create Model Command","url":"cli-create-model","content":"<p>Creates a model file with the specified model class name. Example usage:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">php index.php create_model Foo<\/pre>\r\n\r\n<p>This would create a model file at <code>app\/model\/foo.php<\/code> with the following content:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">&lt;?php\r\n\r\nnamespace App\\Model;\r\n\r\nclass Foo extends \\Core\\Model\\Base {\r\n\r\n}<\/pre>\r\n\r\n<p><strong>Note:<\/strong> Make sure to use the correct capitalization for the class name while using this command. For example, <code>bar<\/code> would be incorrect, but <code>Bar<\/code> would be fine.<\/p>"},{"id":"16","order":"4","guidecategory":"1","title":"Autoloading","url":"autoloading","content":"<p>Burner CMS uses a PHP feature known as <a href=\"http:\/\/php.net\/manual\/en\/language.oop5.autoload.php\">autoloading<\/a> to automatically include class files. To determine which files are loaded for which classes, Burner follows the <a href=\"https:\/\/github.com\/php-fig\/fig-standards\/blob\/master\/accepted\/PSR-0.md\">PSR-0<\/a> standard pretty closely, but with some changes.<\/p>\r\n\r\n<p>For anyone new to the concept of autoloading, it's like this: you can use classes without having to manually include the class files yourself. Burner uses the namespace and class name to find and include the class file automatically for you.<\/p>\r\n<hr\/>\r\n\r\n<h3>Examples<\/h3>\r\n<p>Here's a few examples of classes and which files are loaded for them:<\/p>\r\n\r\n<ul>\r\n<li>&bull; <code>\\Foo<\/code> maps to <code>foo.php<\/code><\/li>\r\n<li>&bull; <code>\\App\\Foo<\/code> maps to <code>app\/foo.php<\/code><\/li>\r\n<li>&bull; <code>\\App\\Model\\Foo<\/code> maps to <code>app\/model\/foo.php<\/code><\/li>\r\n<li>&bull; <code>\\App\\Model\\Foo_Bar<\/code> maps to <code>app\/model\/foo\/bar.php<\/code><\/li>\r\n<li>&bull; <code>\\App\\Model\\Foo_Bar\\Baz<\/code> maps to <code>app\/model\/foo_bar\/baz.php<\/code><\/li>\r\n<li>&bull; <code>\\App\\Controller\\Baz<\/code> maps to <code>app\/controller\/baz.php<\/code><\/li>\r\n<li>&bull; <code>\\App\\Vendor\\Admin\\Controller\\Admin<\/code> maps to <code>app\/vendor\/admin\/controller\/admin.php<\/code><\/li>\r\n<\/ul>\r\n<hr\/>\r\n\r\n<h3>Exceptions<\/h3>\r\n<p>As stated above, there are exceptions to how Burner follows the PSR-0 standard. Here they are:<\/p>\r\n\r\n<ul>\r\n<li>&bull; File and directory names are always completely lowercase.<\/li>\r\n<li>&bull; <code>\\Core\\&lt;class&gt;<\/code> maps to <code>burner\/&lt;class&gt;.php<\/code><\/li>\r\n<li>&bull; <code>\\Library\\&lt;class&gt;<\/code> maps to <code>burner\/library\/&lt;class&gt;.php<\/code><\/li>\r\n<li>&bull; <code>\\Column\\&lt;class&gt;<\/code> maps to <code>burner\/column\/&lt;class&gt;.php<\/code><\/li>\r\n<\/ul>\r\n<hr\/>\r\n\r\n<h3>Customizations<\/h3>\r\n<p>Because 3rd-party PHP libraries come in a wide variety of class naming schemes, Burner allows you to specify additional autoloading rules. Here's an example:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">\\Core\\Autoload::set('\/^Awesome\/', function($class_name) {\r\n\r\n    $path = str_replace('_', '\/', $class_name);\r\n    return \"awesome-library\/$path.php\";\r\n\r\n});<\/pre>\r\n\r\n<p><strong>Note:<\/strong> When used, this feature does add overhead to class autoloading, so use it sparingly. If you only need to load 3rd-party classes in one place, then consider placing this config code right before you need to load those 3rd-party classes. However, if you need to use those 3rd-party classes in many places, then <code>app\/config\/&lt;configuration&gt;\/config.php<\/code> might be a better place for this config code.<\/p>"},{"id":"17","order":"1","guidecategory":"1","title":"Start Here","url":"start-here","content":"<p>The best way to learn how to use Burner CMS is to just read through all of the guides in <strong>The Basics<\/strong> category. Start with the installation guide, skim over the guides which are designed to be overviews of important topics, and then go through the photo gallery tutorial. After that, then you should have a good enough idea of how Burner works to be able to understand the other guide categories.<\/p>"},{"id":"18","order":"2","guidecategory":"1","title":"Requirements","url":"requirements","content":"<p>A few things are required to install and run Burner CMS:<\/p>\r\n<ul>\r\n<li>&bull; Apache with Mod Rewrite enabled<\/li>\r\n<li>&bull; PHP 5.3 of higher<\/li>\r\n<li>&bull; MySQL<\/li>\r\n<\/ul>\r\n<hr\/>\r\n\r\n<h3>Highly Recommended<\/h3>\r\n<p>Access to the PHP command line interface is highly recommended, because it allows you to use all of Burner's helpful CLI development tools. Not sure if you have access? If you can get this command to run successfully from your terminal, then you should be all set:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">php --version<\/pre>\r\n\r\n<p>If your web host doesn't support command line access, then we would highly recommend that you check out <a target=\"_blank\" href=\"https:\/\/www.linode.com\/\">Linode<\/a>. It's a very affordable and solid VPS hosting service. And no, we aren't getting paid to say this.<\/p>"},{"id":"19","order":"2","guidecategory":"2","title":"Select Queries","url":"model-select","content":"<p>Creating a basic select query is simple:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$query = \\App\\Model\\Article::select();\r\n$rows = $query-&gt;fetch();<\/pre>\r\n\r\n<p>The <code>select()<\/code> static method returns a <a href=\"..\/api\/latest\/Mysql.Select\">Mysql\\Select<\/a> object. The above example fetches all columns in the user table. This can be reduced by using method chaining:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$rows = \\App\\Model\\Article::select()-&gt;fetch();<\/pre>\r\n\r\n<p><code>$rows<\/code> would then contain an array of <code>App\\Model\\Article<\/code> objects::<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">Array\r\n(\r\n    [0] => App\\Model\\Article Object\r\n        (\r\n            [id] =&gt; 1\r\n            [title] =&gt; Hello, World!\r\n            [content] =&gt; The quick brown fox jumps over the lazy dog.\r\n        )\r\n\r\n    [1] => App\\Model\\Article Object\r\n        (\r\n            [id] =&gt; 2\r\n            [title] =&gt; Second Article\r\n            [content] =&gt; The lazy dog rests while the brown fox jumps.\r\n        )\r\n\r\n)<\/pre>\r\n<hr\/>\r\n\r\n<h3>Where<\/h3>\r\n<p>Valid operators include: =, !=, >, >=, <, <=, LIKE, MATCH, MATCH_BOOLEAN. Add where conditions to your queries like so:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$rows = \\App\\Model\\Article::select()\r\n    -&gt;where('title', '=', 'Second Article')\r\n    -&gt;fetch();<\/pre>\r\n\r\n<p>Adding multiple where conditions can be done by using the <code>and_where()<\/code> and <code>or_where()<\/code> methods:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$rows = \\App\\Model\\Article::select()\r\n    -&gt;where('title', '=', 'Second Article')\r\n    -&gt;or_where('id', '!=', 2)\r\n    -&gt;fetch();<\/pre>\r\n\r\n<p>The methods <code>where_null()<\/code>, <code>where_not_null()<\/code>, <code>and_where_null()<\/code>, <code>and_where_not_null()<\/code>, <code>or_where_null()<\/code>, and <code>or_where_not_null()<\/code> also exist for selecting based on null-valued columns.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$rows = \\App\\Model\\Article::select()\r\n    -&gt;where_null('content')\r\n    -&gt;fetch();<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3>Ordering Results<\/h3>\r\n<p>You can order results by using the <code>order_desc()<\/code> and <code>order_asc()<\/code> methods:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$rows = \\App\\Model\\Article::select()\r\n    -&gt;order_desc('id')\r\n    -&gt;fetch();<\/pre>\r\n\r\n<p>Multiple order_desc() and order_asc() methods can be used in one query. However, it's important to note that order of use matters:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$rows = \\App\\Model\\Article::select()\r\n    -&gt;order_desc('id')\r\n    -&gt;order_asc('title')\r\n    -&gt;fetch();\r\n\r\n\/\/ Not the same!\r\n\r\n$rows = \\App\\Model\\Article::select()\r\n    -&gt;order_asc('title')\r\n    -&gt;order_desc('id')\r\n    -&gt;fetch();<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3>Limit &amp; Offset<\/h3>\r\n<p>Setting a result limit or offset is easy:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">\/\/ Limit\r\n$rows = \\App\\Model\\Article::select()\r\n    -&gt;limit(5)\r\n    -&gt;fetch();\r\n\r\n\/\/ Both\r\n$rows = \\App\\Model\\Article::select()\r\n    -&gt;limit(5)\r\n    -&gt;offset(10)\r\n    -&gt;fetch();<\/pre>\r\n\r\n<p>To make pagination a little easier, the <code>page()<\/code> method is also provided. The first argument is the current page, and the second argument is the number of records per page.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$rows = \\App\\Model\\Article::select()\r\n    -&gt;page(2, 10)\r\n    -&gt;fetch();<\/pre>\r\n\r\n<p>If you only need to select a single row, then using the <code>single()<\/code> method is the way to go. This will return an object if data is found matching the criteria, and <code>null<\/code> otherwise.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$one_row = \\App\\Model\\Article::select()\r\n    -&gt;where('title', '=', 'Second Article')\r\n    -&gt;single();<\/pre>\r\n\r\n<p>If you only need to select a single row based on its automatically assigned row ID, then use the <code>id()<\/code> static method.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$one_row = \\App\\Model\\Article::id(2);\r\n\r\n\/\/ Exactly like the following\r\n\r\n$one_row = \\App\\Model\\Article::select()\r\n    -&gt;where('id', '=', 2)\r\n    -&gt;single();<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3>Selecting Specific Columns<\/h3>\r\n<p>If you only want to return specific columns, that is easy to do as well:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$rows = \\App\\Model\\Article::select()\r\n    -&gt;column('title')\r\n    -&gt;fetch();<\/pre>\r\n\r\n<pre class=\"prettyprint lang-xml\">Array\r\n(\r\n    [0] => App\\Model\\Article Object\r\n        (\r\n            [title] =&gt; Hello, World!\r\n        )\r\n\r\n    [1] => App\\Model\\Article Object\r\n        (\r\n            [title] =&gt; Second Article\r\n        )\r\n\r\n)<\/pre>\r\n\r\n<p><strong>Note:<\/strong> The column() method can be used multiple times to specify multiple columns that should be returned.<\/p>\r\n\r\n<p>Aliases can be provided as well:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$rows = \\App\\Model\\Article::select()\r\n    -&gt;column('title', 'article_name')\r\n    -&gt;fetch();<\/pre>\r\n\r\n<pre class=\"prettyprint lang-xml\">Array\r\n(\r\n    [0] => App\\Model\\Article Object\r\n        (\r\n            [article_name] =&gt; Hello, World!\r\n        )\r\n\r\n    [1] => App\\Model\\Article Object\r\n        (\r\n            [article_name] =&gt; Second Article\r\n        )\r\n\r\n)<\/pre>\r\n\r\n<p>It's also possible to select MIN, MAX, COUNT, SUM, and AVG columns:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$rows = \\App\\Model\\Article::select()\r\n    -&gt;min_column('foo')\r\n    -&gt;max_column('bar')\r\n    -&gt;avg_column('baz')\r\n    -&gt;sum_column('some_column')\r\n    -&gt;count_column('another_column')\r\n    -&gt;fetch();<\/pre>\r\n\r\n<p>These can be given aliases as well:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$rows = \\App\\Model\\Article::select()\r\n    -&gt;min_column('foo', 'some_alias')\r\n    -&gt;fetch();<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3>Joins<\/h3>\r\n<p>Many ORMs automatically join tables for the developer, but Burner CMS's ORM does not behave this way. The reason for this is simply that how such behavior actually works is often ambiguous to you, the application developer. Also, queries generated in such a way are not always as efficient as they should be. For these reasons, application developers still have to manually define join queries.<\/p>\r\n\r\n<p>We are sorry. Really, we are. If you have any ideas on how to streamline joins without adding ambiguity, then please submit a ticket in the issue tracker.<\/p>\r\n\r\n<p>With that said, join queries can be created in an object-oriented fashion by using the <code>inner_join()<\/code>, <code>left_join()<\/code>, or <code>right_join()<\/code> methods. The first argument is the table to join, the second is the first column to compare in the ON clause, the third is the comparison operator, and the last is the second column to compare:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">\/\/ Inner join\r\n$rows = \\App\\Model\\Article::select()\r\n    -&gt;inner_join('user', 'user.id', '=', 'article.user')\r\n    -&gt;fetch();\r\n\r\n\/\/ Left join\r\n$rows = \\App\\Model\\Article::select()\r\n    -&gt;left_join('user', 'user.id', '=', 'article.user')\r\n    -&gt;fetch();\r\n\r\n\/\/ Right join\r\n$rows = \\App\\Model\\Article::select()\r\n    -&gt;right_join('user', 'user.id', '=', 'article.user')\r\n    -&gt;fetch();<\/pre>\r\n\r\n<p>You can also use the column methods to select which columns are returned from the join:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$rows = \\App\\Model\\Article::select()\r\n    -&gt;column('user.id', 'user_id')\r\n    -&gt;column('user.email', 'user_email')\r\n    -&gt;column('article.title', 'title')\r\n    -&gt;column('article.content', 'content')\r\n    -&gt;inner_join('user', 'user.id', '=', 'article.user')\r\n    -&gt;fetch();<\/pre>"},{"id":"20","order":"1","guidecategory":"2","title":"Insert & Update Queries","url":"model-insert-and-update","content":"<p>Inserting data into the database by using the ORM is a short process. First create an instance of the appropriate data model, then set the column values, and finally use the <code>save()<\/code> method to finally insert it.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$row = new \\App\\Model\\Article();\r\n$row-&gt;title = 'Quixotic Article';\r\n$row-&gt;content = 'The quick brown fox jumps over the lazy dog.';\r\n$row-&gt;save();\r\n\r\n\/\/ $row->id should now be set\r\necho $row->id;<\/pre>\r\n\r\n<p>Values for some special column types, such as the <code>Password<\/code> type, can't be set this way though. The reason is that when setting column values in this way, you are actually defining the raw values to be inserted into the database. Password columns are supposed to contain hashed data, so all Password columns automatically have a helper method named <code>set_<em>column_name<\/em>()<\/code>, which hashes and sets password values.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$row = new \\App\\Model\\User();\r\n$row-&gt;email = 'foo@gmail.com';\r\n$row-&gt;set_password('awesome');\r\n$row-&gt;save();<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3>Update<\/h3>\r\n<p>Update queries also use the <code>save()<\/code> method. So how does Burner determine to run an update query instead of an insert? When the <code>id<\/code> property is not empty, then Burner assumes that the row already exists.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">\/\/ Update query\r\n$row = new \\App\\Model\\Article();\r\n$row-&gt;id = 1;\r\n$row-&gt;title = 'Quixotic Article';\r\n$row-&gt;content = 'The quick brown fox jumps over the lazy dog.';\r\n$row->save();\r\n\r\n\/\/ Insert query\r\n$row = new \\App\\Model\\Article();\r\n$row-&gt;title = 'Quixotic Article';\r\n$row-&gt;content = 'The quick brown fox jumps over the lazy dog.';\r\n$row-&gt;save();<\/pre>\r\n\r\n<pre class=\"prettyprint lang-php\">\/\/ Insert\r\n$row = new \\App\\Model\\Article();\r\n$row-&gt;title = 'Quixotic Article';\r\n$row-&gt;content = 'The quick brown fox jumps over the lazy dog.';\r\n$row->save();\r\n\r\n\/\/ Then update\r\n$row-&gt;title = 'New Title';\r\n$row-&gt;save();<\/pre>\r\n\r\n<pre class=\"prettyprint lang-php\">\/\/ Select single row\r\n$row = \\App\\Model\\Article::select()\r\n    -&gt;where('title', '=', 'Hello, World!')\r\n    -&gt;single();\r\n\r\n\/\/ Then update\r\nif($row !== null) {\r\n\r\n    $row-&gt;title = 'New Title';\r\n    $row-&gt;save();\r\n\r\n}<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3>Input Methods<\/h3>\r\n<p>Because web apps typically deal with a lot of form data, every Burner CMS model class has the <code>from_array()<\/code> and <code>from_post()<\/code> static helper methods. When passed an associative array of data, from_array() creates a new model instance and imports the given data. The main advantage of using this method is that it handles special column types - like password columns - automatically.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$row = \\App\\Model\\User::from_array(array('email' => 'foo@gmail.com', 'password' => 'awesome'));\r\n$row-&gt;save();<\/pre>\r\n\r\n<p>The <code>from_post()<\/code> method is a step up in usefulness from the <code>from_array()<\/code> method. This method takes an array of column names as its first argument, looks for those column names in <code>$_POST<\/code>, and finally uses from_array() to create a new model instance.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$row = \\App\\Model\\User::from_post(array('email', 'password'));\r\n$row-&gt;save();\r\n\r\n\/\/ Equivalent to this\r\n\r\n$row = new \\App\\Model\\User();\r\n$row-&gt;email = \\Library\\Input::post('email');\r\n$row-&gt;set_password(\\Library\\Input::post('password'));\r\n$row-&gt;save();<\/pre>\r\n\r\n<p>Additionally, the <code>merge_array()<\/code> and <code>merge_post()<\/code> non-static methods are available. These are just like from_array() and from_post() respectively, but they are used to override existing data. Usually they are used before an update operation.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">\/\/ Select single row\r\n$row = \\App\\Model\\Article::select()\r\n    -&gt;where('title', '=', 'Hello, World!')\r\n    -&gt;single();\r\n\r\n\/\/ Then update\r\nif($row !== null) {\r\n\r\n    $row-&gt;merge_post(array('title', 'content'));\r\n    $row-&gt;save();\r\n\r\n}<\/pre>"},{"id":"21","order":"3","guidecategory":"2","title":"Delete Queries","url":"model-delete","content":"<p>Delete queries work pretty much exactly like select queries.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">\/\/ Delete everything\r\n\\App\\Model\\Article::delete()-&gt;execute();\r\n\r\n\/\/ Delete one specific row\r\n\\App\\Model\\Article::delete()\r\n    -&gt;where('title', '=', 'Hello, World!')\r\n    -&gt;limit(1)\r\n    -&gt;execute();<\/pre>\r\n\r\n<p>Records can also be deleted by using the <code>erase()<\/code> method. This method takes all populated column properties of an object, and then creates WHERE conditions with them.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">\/\/ Select a single row\r\n$row = \\App\\Model\\Article::id(2);\r\n\r\n\/\/ Delete it\r\nif($row !== null) {\r\n\r\n    $row-&gt;erase();\r\n\r\n}<\/pre>\r\n\r\n<p>Note that erase() doesn't limit the number of records deleted, so a query like the following could possibly delete more than one record.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$row = new \\App\\Model\\Article();\r\n$row-&gt;title = 'Hello, World!';\r\n$row-&gt;erase();\r\n\r\n\/\/ Same as this\r\n\r\n\\App\\Model\\Article::delete()\r\n    -&gt;where('title', '=', 'Hello, World!')\r\n    -&gt;execute();<\/pre>"},{"id":"22","order":"4","guidecategory":"2","title":"Model Column Types","url":"model-column-types","content":"<hr\/>\r\n<ul>\r\n<li>&bull; <a href=\"#belongsto\">BelongsTo<\/a><\/li>\r\n<li>&bull; <a href=\"#boolean\">Boolean<\/a><\/li>\r\n<li>&bull; <a href=\"#char\">Char<\/a><\/li>\r\n<li>&bull; <a href=\"#date\">Date<\/a><\/li>\r\n<li>&bull; <a href=\"#decimal\">Decimal<\/a><\/li>\r\n<li>&bull; <a href=\"#email\">Email<\/a><\/li>\r\n<li>&bull; <a href=\"#file\">File<\/a><\/li>\r\n<li>&bull; <a href=\"#hasmany\">HasMany<\/a><\/li>\r\n<li>&bull; <a href=\"#image\">Image<\/a><\/li>\r\n<li>&bull; <a href=\"#int\">Int<\/a><\/li>\r\n<li>&bull; <a href=\"#manytomany\">ManyToMany<\/a><\/li>\r\n<li>&bull; <a href=\"#order\">Order<\/a><\/li>\r\n<li>&bull; <a href=\"#password\">Password<\/a><\/li>\r\n<li>&bull; <a href=\"#text\">Text<\/a><\/li>\r\n<li>&bull; <a href=\"#time\">Time<\/a><\/li>\r\n<li>&bull; <a href=\"#varchar\">Varchar<\/a><\/li>\r\n<\/ul>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"belongsto\">BelongsTo<\/h3>\r\n<p>Used to reference a single record in another model. The property name should match the name of the model being referenced, but be all lowercase. An extension of the int type.<\/p>\r\n<pre class=\"prettyprint lang-php\">class Foo extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = BelongsTo\r\n     *\/\r\n    public $category;\r\n\r\n}<\/pre>\r\n\r\n<pre class=\"prettyprint lang-php\">$row = new \\App\\Model\\Foo();\r\n$row-&gt;category = 123;\r\n$row-&gt;save();\r\n\r\n\/\/ Shortcut for \\App\\Model\\Category::id($row-&gt;category)\r\n$category = $row-&gt;category();<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"boolean\">Boolean<\/h3>\r\n<p>Used for storing boolean values (1 or 0). Internally uses the MySQL <code>TINYINT(1)<\/code> type.<\/p>\r\n<pre class=\"prettyprint lang-php\">class Foo extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Boolean\r\n     *\/\r\n    public $col_name;\r\n\r\n}<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"char\">Char<\/h3>\r\n<p>Used for storing string values. Internally uses the MySQL <a target=\"_blank\" href=\"http:\/\/dev.mysql.com\/doc\/refman\/5.0\/en\/char.html\">char<\/a> type. <code>length<\/code> option is required.<\/p>\r\n<pre class=\"prettyprint lang-php\">class Foo extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Char\r\n     * @option length = 100\r\n     *\/\r\n    public $col_name;\r\n\r\n}<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"date\">Date<\/h3>\r\n<p>Used for storing dates. Internally uses the MySQL <a target=\"_blank\" href=\"http:\/\/dev.mysql.com\/doc\/refman\/5.1\/en\/datetime.html\">date<\/a> type.<\/p>\r\n<pre class=\"prettyprint lang-php\">class Foo extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Date\r\n     *\/\r\n    public $col_name;\r\n\r\n}<\/pre>\r\n\r\n<p><strong>Note:<\/strong> When storing data in a date column, be sure to use the <code>YYYY-MM-DD<\/code> format. Invalid dates are converted to <code>0000-00-00<\/code> by MySQL.<\/p>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"decimal\">Decimal<\/h3>\r\n<p>Used for storing exact numeral data values. Internally uses the MySQL <a target=\"_blank\" href=\"http:\/\/dev.mysql.com\/doc\/refman\/5.0\/en\/fixed-point-types.html\">decimal<\/a> type. <code>max<\/code> and <code>digits<\/code> options are required. Max represents the precision, and digits represents the scale. The names of these options may be changed, because they are currently misleading.<\/p>\r\n<pre class=\"prettyprint lang-php\">class Foo extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Decimal\r\n     * @option max= 7\r\n     * @option digits = 2\r\n     *\/\r\n    public $col_name;\r\n\r\n}<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"email\">Email<\/h3>\r\n<p>Used for email addresses. An extension of the Varchar type. It has added validation to check to make sure that the given data is a correctly formatted email address. <code>length<\/code> option is required.<\/p>\r\n<pre class=\"prettyprint lang-php\">class Foo extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Email\r\n     * @option length = 200\r\n     *\/\r\n    public $col_name;\r\n\r\n}<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"file\">File<\/h3>\r\n<p>Used for storing uploaded files. An extension of the Char type. Files are uploaded to a specified location, and the file extension is stored in the database column.<\/p>\r\n<pre class=\"prettyprint lang-php\">class Foo extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = File\r\n     *\/\r\n    public $attachment;\r\n\r\n    public function attachment_path() {\r\n\r\n        return \"static\/attachments\/{$this-&gt;id}\";\r\n\r\n    }\r\n\r\n}<\/pre>\r\n\r\n<pre class=\"prettyprint lang-php\">\/\/ Uploading a file\r\n$row = \\App\\Model\\Foo::from_post(array('attachment'), true);\r\n$errors = $row-&gt;valid();\r\n\r\nif(empty($errors)) {\r\n\r\n    $row-&gt;save();\r\n\r\n}\r\n\r\n\/\/ Get file URL\r\necho $row-&gt;attachment_url();<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"hasmany\">HasMany<\/h3>\r\n<p>Used to reference a collection of records in another model. Doesn't actually add any new columns to the MySQL table. <code>model<\/code> and <code>column<\/code> options are required. Model should be the name of the referenced model. Column should be the name of the BelongsTo property in the referenced model that points to this model.<\/p>\r\n<pre class=\"prettyprint lang-php\">class Article extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = HasMany\r\n     * @option model = Comment\r\n     * @option column = article \r\n     *\/\r\n    public $comments;\r\n\r\n}<\/pre>\r\n\r\n<pre class=\"prettyprint lang-php\">$article = \\App\\Model\\Article::id(123);\r\n\r\n\/\/ Select\r\n$comments = $article-&gt;comments()\r\n    -&gt;select()\r\n    -&gt;and_where('foo', '=', 'bar')\r\n    -&gt;fetch();\r\n\r\n\/\/ Delete\r\n$article-&gt;comments()\r\n    -&gt;delete()\r\n    -&gt;or_where('foo', '=', 'bar')\r\n    -&gt;execute();<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"image\">Image<\/h3>\r\n<p>Used for storing uploaded image files. An extension of the File type. Images are uploaded to a specified location, and the file extension is stored in the database column. Validates that uploaded files are images.<\/p>\r\n<pre class=\"prettyprint lang-php\">class Foo extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Image\r\n     *\/\r\n    public $attachment;\r\n\r\n    public function attachment_path() {\r\n\r\n        return \"static\/attachments\/{$this-&gt;id}\";\r\n\r\n    }\r\n\r\n}<\/pre>\r\n\r\n<pre class=\"prettyprint lang-php\">\/\/ Uploading an image\r\n$row = \\App\\Model\\Foo::from_post(array('attachment'), true);\r\n$errors = $row-&gt;valid();\r\n\r\nif(empty($errors)) {\r\n\r\n    $row-&gt;save();\r\n\r\n}\r\n\r\n\/\/ Get file URL\r\necho $row-&gt;attachment_url();<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"int\">Int<\/h3>\r\n<p>Used for storing integer values. Internally uses the MySQL <a target=\"_blank\" href=\"http:\/\/dev.mysql.com\/doc\/refman\/5.0\/en\/integer-types.html\">int<\/a> type.<\/p>\r\n<pre class=\"prettyprint lang-php\">class Foo extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Int\r\n     *\/\r\n    public $col_name;\r\n\r\n}<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"manytomany\">ManyToMany<\/h3>\r\n<p>Used to define a many-to-many relationship to another model. Doesn't actually add any new columns to the MySQL table. All of the options are required. Model should be the name of the referenced model. Middleman should be the name of the middleman model.<\/p>\r\n<pre class=\"prettyprint lang-php\">class User extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = ManyToMany\r\n     * @option middleman = Membership\r\n     * @option model = Group\r\n     *\/\r\n    public $groups;\r\n\r\n}<\/pre>\r\n\r\n<pre class=\"prettyprint lang-php\">class Group extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = ManyToMany\r\n     * @option middleman = Membership\r\n     * @option model = User\r\n     *\/\r\n    public $users;\r\n\r\n}<\/pre>\r\n\r\n<pre class=\"prettyprint lang-php\">class Membership extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = BelongsTo\r\n     *\/\r\n    public $user;\r\n\r\n    \/**\r\n     * @option type = BelongsTo\r\n     *\/\r\n    public $group;\r\n\r\n}<\/pre>\r\n\r\n<pre class=\"prettyprint lang-php\">$article = \\App\\Model\\Article::id(123);\r\n$group =  \\App\\Model\\Group::id(321);\r\n\r\n\/\/ Select\r\n$groups = $article-&gt;groups()\r\n    -&gt;select()\r\n    -&gt;and_where('group.foo', '=', 'bar')\r\n    -&gt;fetch();\r\n\r\n\/\/ Add\r\n$article-&gt;groups()-&gt;add($group-&gt;id);\r\n\/\/ or $group-&gt()-&gtarticles()-&gt;add($article-&gtid)\r\n\r\n\/\/ Remove\r\n$article-&gt;groups()-&gt;remove($group-&gt;id);\r\n\/\/ or $group-&gt()-&gtarticles()-&gt;remove($article-&gtid)<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"order\">Order<\/h3>\r\n<p>Used to make records sortable via drag-and-drop in the admin. Internally uses the MySQL <a target=\"_blank\" href=\"http:\/\/dev.mysql.com\/doc\/refman\/5.0\/en\/integer-types.html\">int<\/a> type.<\/p>\r\n<pre class=\"prettyprint lang-php\">\/**\r\n * @option admin_order = order\r\n * @option admin_page_size = false\r\n *\/\r\nclass Foo extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Order\r\n     *\/\r\n    public $col_name;\r\n\r\n}<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"password\">Password<\/h3>\r\n<p>Used for storing hashed passwords. Internally uses the MySQL <a target=\"_blank\" href=\"http:\/\/dev.mysql.com\/doc\/refman\/5.0\/en\/char.html\">char(128)<\/a> type.<\/p>\r\n<pre class=\"prettyprint lang-php\">class Foo extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Password\r\n     *\/\r\n    public $pin;\r\n\r\n}<\/pre>\r\n\r\n<pre class=\"prettyprint lang-php\">\/\/ Automatically created method, which hashes and sets a string\r\n$row = new \\App\\Model\\Foo();\r\n$row-&gt;set_pin('my_password');\r\n$row-&gt;save();<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"text\">Text<\/h3>\r\n<p>Used for storing large text values. Internally uses the MySQL <a target=\"_blank\" href=\"http:\/\/dev.mysql.com\/doc\/refman\/5.0\/en\/blob.html\">text<\/a> type.<\/p>\r\n<pre class=\"prettyprint lang-php\">class Foo extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Text\r\n     *\/\r\n    public $col_name;\r\n\r\n}<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"time\">Time<\/h3>\r\n<p>Used for storing times. Internally uses the MySQL <a target=\"_blank\" href=\"http:\/\/dev.mysql.com\/doc\/refman\/5.0\/en\/time.html\">time<\/a> type.<\/p>\r\n<pre class=\"prettyprint lang-php\">class Foo extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Time\r\n     *\/\r\n    public $col_name;\r\n\r\n}<\/pre>\r\n\r\n<p><strong>Note:<\/strong> When storing data in a time column, be sure to use the <code>HH:MM:SS<\/code> format. Invalid dates are converted to <code>00:00:00<\/code> by MySQL.<\/p>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"varchar\">Varchar<\/h3>\r\n<p>Used for storing string values. Internally uses the MySQL <a target=\"_blank\" href=\"http:\/\/dev.mysql.com\/doc\/refman\/5.0\/en\/char.html\">varchar<\/a> type. <code>length<\/code> option is required.<\/p>\r\n<pre class=\"prettyprint lang-php\">class Foo extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Varchar\r\n     * @option length = 100\r\n     *\/\r\n    public $col_name;\r\n\r\n}<\/pre>"},{"id":"23","order":"23","guidecategory":"1","title":"Controllers Overview","url":"controllers","content":"<p>In Burner, controllers are used to display pages, handle user input, and work with models to manipulate the database. Controller classes are placed in the <code>app\/controller<\/code> folder and must extend <code>\\Core\\Controller\\Base<\/code>. Here's a simple controller named <code>Blog<\/code>:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">&lt;?php\r\n\r\nnamespace App\\Controller;\r\n\r\nclass Blog extends \\Core\\Controller\\Base {\r\n\r\n    public function index() {\r\n\r\n        return new \\Core\\Response('This is the blog index!');\r\n\r\n    }\r\n\r\n}<\/pre>\r\n\r\n<p>When routed to, the blog controller <code>index()<\/code> method will output <code>This is the blog index!<\/code> to the screen. Right now the controller isn't routed to though, so let's do that next. Open up <code>app\/config\/route.php<\/code> and add the following to it:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">Route::add('App.Controller.Blog', array(\r\n\r\n\t'GET:blog' =&gt; 'index'\r\n\r\n));<\/pre>\r\n\r\n<p>Now when you visit <code>http:\/\/localhost\/mysite\/blog<\/code> (assuming http:\/\/localhost\/mysite\/ is your base URL), index() will be run and <code>This is the blog index!<\/code> will be output to the screen. Adding an additional method just involves creating the method and then adding a route.<\/p>\r\n<hr\/>\r\n\r\n\r\n<h3>Variable Routes<\/h3>\r\n<p>Burner allows you to define routes which have variable parts to them. When the visited URL matches the given route, then variable portions of the route become arguments for the controller method. This allows you to define a single route for a collection of different pages.<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">&lt;?php\r\n\r\nnamespace App\\Controller;\r\n\r\nclass Blog extends \\Core\\Controller\\Base {\r\n\r\n    public function index() {\r\n\r\n        return new \\Core\\Response('This is the blog index!');\r\n\r\n    }\r\n\r\n    public function view($article_id) {\r\n\r\n        return new \\Core\\Response(\"Page for article with ID: $article_id\");\r\n\r\n    }\r\n\r\n}<\/pre>\r\n\r\n<pre class=\"prettyprint lang-php\">Route::add('App.Controller.Blog', array(\r\n\r\n    'GET:blog' =&gt; 'index',\r\n    'GET:blog\/view\/:int' =&gt; 'view'\r\n\r\n));<\/pre>\r\n\r\n<p>Now if you visit <code>http:localhost\/mysite\/blog\/view\/123<\/code> you will see <code>Page for article with ID: 123<\/code>. If you visit <code>http:localhost\/mysite\/blog\/view\/awesome<\/code>, then you will see a 404 page not found error. The reason for this is that the <code>:int<\/code> token in the route only successfully matches against integer values in that portion of the URL. Here's a list of all of the routing tokens:<\/p>\r\n\r\n<ul>\r\n<li>&bull; <strong>:int<\/strong> matches non-negative integer values.<\/li>\r\n<li>&bull; <strong>:numeric<\/strong> matches non-negative numeric values.<\/li>\r\n<li>&bull; <strong>:alpha<\/strong> matches strings containing letters a-z in both cases.<\/li>\r\n<li>&bull; <strong>:alpha-int<\/strong> a combination of :alpha and :int.<\/li>\r\n<li>&bull; <strong>:alpha-numeric<\/strong> a combination of :alpha and :numeric.<\/li>\r\n<li>&bull; <strong>:words<\/strong> :alpha-int plus the underscore(_), dash(-), and space( ) characters.<\/li>\r\n<li>&bull; <strong>:any<\/strong> matches anything.<\/li>\r\n<li>&bull; <strong>:extension<\/strong> two :alpha divided by a period (:alpha.:alpha).<\/li>\r\n<\/ul>"},{"id":"24","order":"24","guidecategory":"1","title":"Templates Overview","url":"templates","content":"<p>Templates are used to format and display web pages. Templates in Burner are nothing more than regular PHP files with some added functionality.<\/p>\r\n<hr\/>\r\n\r\n\r\n<h3>Loading Templates<\/h3>\r\n<p>Controllers automatically load templates based on the names of the controller class and method. By modifying the blog controller from the <em>\"Controllers Overview\"<\/em> guide we can set it up to load templates rather than use response objects:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">&lt;?php\r\n\r\nnamespace App\\Controller;\r\n\r\nclass Blog extends \\Core\\Controller\\Base {\r\n\r\n    public function index() {\r\n\r\n        \/\/ Nothing here yet...\r\n\r\n    }\r\n\r\n}<\/pre>\r\n\r\n<p>Now create a file at <code>app\/template\/blog\/index.php<\/code> with the following in it:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">Hello, World!<\/pre>\r\n\r\n<p>Now when you visit <code>http:\/\/localhost\/mysite\/blog<\/code> you should see <code>Hello, World!<\/code> displayed to the screen. As you can see, Burner uses the names of the controller class and method to determine which template file to load, and then loads it.<\/p>\r\n<hr\/>\r\n\r\n\r\n<h3>Passing Data<\/h3>\r\n<p>By default, templates aren't provided with any data from your controllers. To pass data, use the <code>data()<\/code> method.<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">&lt;?php\r\n\r\nnamespace App\\Controller;\r\n\r\nclass Blog extends \\Core\\Controller\\Base {\r\n\r\n    public function index() {\r\n\r\n        $this-&gt;data('name', 'Bob');\r\n\r\n    }\r\n\r\n}<\/pre>\r\n\r\n<p>Now the variable <code>$name<\/code> can be accessed in the template like so:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">Hello, &lt;?= $name; ?&gt;!<\/pre>\r\n\r\n<p>Now you should see <code>Hello, Bob!<\/code> when visiting this page.<\/p>\r\n<hr\/>\r\n\r\n\r\n<h3>HTTP Status Codes<\/h3>\r\n<p>You can change the HTTP status code for the page by using the <code>status_code()<\/code> method. This example will cause the page to use the 404 \"page not found\" status code in the HTTP response header:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">&lt;?php\r\n\r\nnamespace App\\Controller;\r\n\r\nclass Blog extends \\Core\\Controller\\Base {\r\n\r\n    public function index() {\r\n\r\n        $this-&gt;data('name', 'Bob');\r\n        $this-&gt;status_code(404);\r\n\r\n    }\r\n\r\n}<\/pre>"},{"id":"25","order":"25","guidecategory":"5","title":"Base Templates","url":"templates-base","content":"<p>Base templates can be defined to greatly reduce the amount of repetition in template files. Generally these base templates are used to define the overall layout of the page. By modifying blog index template (app\/template\/blog\/index.php) from the <em>\"Templates Overview\"<\/em> guide we can set it up to use a base template:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">&lt;?php $this-&gt;base('blog\/base'); ?&gt;\r\n\r\n&lt;!-- Title --&gt;\r\n&lt;?php $this-&gt;set('title', 'Home'); ?&gt;\r\n\r\n&lt;!-- Main Content --&gt;\r\n&lt;?php $this-&gt;extend('content'); ?&gt;\r\n\r\n\t&lt;p&gt;new main content!&lt;\/p&gt;\r\n\t\r\n&lt;?php $this-&gt;end_extend(); ?&gt;<\/pre>\r\n\r\n<p>Now create a file at <code>app\/template\/blog\/base.php<\/code> with the following in it:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n\t&lt;head&gt;\r\n\t\t&lt;title&gt;&lt;?php $this-&gt;section('title'); ?&gt;Default Title&lt;?php $this-&gt;end_section(); ?&gt;&lt;\/title&gt;\r\n\t&lt;\/head&gt;\r\n\t&lt;body&gt;\r\n\t\t&lt;?php $this-&gt;section('content'); ?&gt;\r\n\t\t\t\r\n\t\t\t&lt;!-- Default Main Content --&gt;\r\n\t\t\t\r\n\t\t&lt;?php $this-&gt;end_section(); ?&gt;\r\n\t&lt;\/body&gt;\r\n&lt;\/html&gt;<\/pre>\r\n\r\n<p>Now when you visit <code>http:\/\/localhost\/mysite\/blog<\/code> you should HTML similar to the following displayed to the screen:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n\t&lt;head&gt;\r\n\t\t&lt;title&gt;Home&lt;\/title&gt;\r\n\t&lt;\/head&gt;\r\n\t&lt;body&gt;\r\n\t\t&lt;p&gt;new main content!&lt;\/p&gt;\r\n\t&lt;\/body&gt;\r\n&lt;\/html&gt;<\/pre>\r\n\r\n<p>Obviously, the base template we used here was very small and simple. Larger and more complex layouts will benefit a lot more from the base template system than simple ones like this.<\/p>"},{"id":"26","order":"26","guidecategory":"1","title":"Functions","url":"functions","content":"<p>Burner CMS has a handfull of functions which provide useful functionality throughout Burner applications. Here's an overview of Burner's functions:<\/p>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"url\">url<\/h3>\r\n<p>Returns the full URL to a resource. First argument is the path relative to the application root directory (the folder where index.php resides).<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">\/\/ All examples assume base_url configured to 'localhost\/mysite\/'\r\n\r\necho url();\r\n\/\/ http:\/\/localhost\/mysite\/\r\n\r\necho url('foo\/bar');\r\n\/\/ http:\/\/localhost\/mysite\/foo\/bar\r\n\r\necho url('static\/admin\/css\/rewrite.css');\r\n\/\/ http:\/\/localhost\/mysite\/static\/admin\/css\/rewrite.css<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"redirect\">redirect<\/h3>\r\n<p>Redirects the browser to the specified URL. First argument is the path relative to the application root directory, just like with <code>url()<\/code>.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">\/\/ All examples assume base_url configured to 'localhost\/mysite\/'\r\n\r\nredirect();\r\n\/\/ goes to http:\/\/localhost\/mysite\/\r\n\r\nredirect('foo\/bar');\r\n\/\/ goes to http:\/\/localhost\/mysite\/foo\/bar<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"login_redirect\">login_redirect<\/h3>\r\n<p>Redirects the browser to the login page. Once done logging in, then the user will be redirected to the specified URL. First argument is the path relative to the application root directory, just like with <code>url()<\/code>.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">login_redirect('foo\/bar');\r\n\/\/ redirects to http:\/\/localhost\/mysite\/foo\/bar after logging in<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"is_post\">is_post<\/h3>\r\n<p>Returns <code>true<\/code> if <code>$_SERVER['REQUEST_METHOD']<\/code> equals <code>POST<\/code>. Returns <code>false<\/code> otherwise.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">if(is_post()) {\r\n\r\n    echo 'POST request!';\r\n\r\n}<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"e\">e<\/h3>\r\n<p>A shortcut for <a target=\"_blank\" href=\"http:\/\/php.net\/htmlentities\">htmlentities<\/a>. Commonly used in templates to escape potentially harmful HTML data.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">Hello, &lt;?= e($name); ?&gt;!<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"to_php_namespace\">to_php_namespace<\/h3>\r\n<p>Converts a fully namespaced class name in dot notation to regular PHP namespace notation.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">echo to_php_namespace('App.Model.Foo');\r\n\/\/ \\App\\Model\\Foo<\/pre>"},{"id":"27","order":"27","guidecategory":"1","title":"Photo Gallery Tutorial","url":"tutorial-photo-gallery","content":"<p>This tutorial will guide you through the process of creating a simple photo gallery, which \u2014 like all Burner applications \u2014 will be manageable from the admin control panel. During the process you will see a small subset of some of the very cool features that Burner has, even though it's only in beta.<\/p>\r\n\r\n<p><strong>Note:<\/strong> For this tutorial, it is assumed that you have already installed Burner and have read through <em>\"The Basics\"<\/em> section of the documentation.<\/p>\r\n\r\n<p><strong>Also:<\/strong> Many of the screenshots in this tutorial show an older version of Burner. For this reason, the generated admin control panel for your application will look slightly different. The code examples have however been updated to reflect the latest version of Burner.<\/p>\r\n<hr\/>\r\n\r\n\r\n<h3>Define The Model<\/h3>\r\n<p>The first step to creating any Burner application is to define the data models. Each model represents a different table in your database. The purpose of having defined models is that they allow you to interact with your database in an object-oriented fashion, which as you will see later on is very nice. Additionally, models are compatible with the admin control panel, so any data stored with your models can be easily managed from the admin control panel.<\/p>\r\n\r\n<p>Because this is an simple application, there will be only one model to create, which\r\n\t\t\t\tis the <code>Photo<\/code> model. To create this model, make a new file located at\r\n\t\t\t\t<code>app\/model\/photo.php<\/code> and place the following code in it:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">&lt;?php\r\n\r\nnamespace App\\Model;\r\n\r\nclass Photo extends \\Core\\Model\\Base {\r\n\r\n\t\/**\r\n\t * @option type = Varchar\r\n\t * @option length = 100\r\n\t * @option required = Title field is required.\r\n\t *\/\r\n\tpublic $title;\r\n\r\n\t\/**\r\n\t * @option type = Text\r\n\t *\/\r\n\tpublic $description;\r\n\r\n}<\/pre>\r\n\r\n<p>Right here we have a pretty bare-bones model. It only has two fields: title and description. As you can see, fields are nothing more than properties with <code>@option<\/code> annotations added to the doc comment above them. The title field is of Varchar type, has a max length of 100, and is required. The description field is just a plain old Text column and is not required.<\/p>\r\n\r\n<p>Now if you were to run <code>php index.php sql photo<\/code> from the terminal, then the it would spit out the following SQL to your screen:<\/p>\r\n\r\n<pre class=\"prettyprint lang-sql\">CREATE TABLE `photo`(\r\n`id` INT NOT NULL AUTO_INCREMENT,\r\n`title` VARCHAR(100),\r\n`description` TEXT,\r\nPRIMARY KEY(`id`)\r\n) ENGINE = MyISAM;<\/pre>\r\n\r\n<p>What you are seeing here is a fantastic feature that all Burner models have. All you have to do is define your models, and then Burner can automatically generates the SQL for you. Even better yet, if you run the <code>php index.php sync photo<\/code> command, then Burner will drop the photo table (if it exists) and then create it, so you don't have to do so manually. This can greatly speed up development time.<\/p>\r\n\r\n<p>OK, so let's continue on. As it currently is, the photo model can only store the title and descriptions of our photos. While that's all fun and great, we need to be able to actually upload photos, so let's add another field:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">&lt;?php\r\n\r\nnamespace App\\Model;\r\n\r\nclass Photo extends \\Core\\Model\\Base {\r\n\t\r\n\t\/**\r\n\t * @option type = Image\r\n\t * @option required = Image field is required.\r\n\t *\/\r\n\tpublic $image;\r\n\r\n\t\/**\r\n\t * @option type = Varchar\r\n\t * @option length = 100\r\n\t * @option required = Title field is required.\r\n\t *\/\r\n\tpublic $title;\r\n\r\n\t\/**\r\n\t * @option type = Text\r\n\t *\/\r\n\tpublic $description;\r\n\r\n\t\/**\r\n\t * Image Path\r\n\t * @return string\r\n\t *\/\r\n\tpublic function image_path() {\r\n\r\n\t\treturn \"static\/photo\/{$this->id}\";\r\n\r\n\t}\r\n\r\n}<\/pre>\r\n\r\n<p>Burner has two kinds of built in fields, which automatically handle file uploads: <code>File<\/code> and <code>Image<\/code>. Image simply inherits File, so they work almost exactly the same as each other, with the exception that Image only accepts image files.<\/p>\r\n\r\n<p>In addition to defining the <code>$image<\/code> property, we had to define a special function called <code>image_path()<\/code>. All this does is tell Burner where to upload the image files to. As you can see, there is no file extension given. Burner automatically detects and uses the correct file extension for us.<\/p>\r\n\r\n<p>The only things left to do are create the <code>static\/photo<\/code> directory (relative to where index.php is located), and then run <code>php index.php sync photo<\/code> to create the database table.<\/p>\r\n<hr\/>\r\n\r\n\r\n<h3>Admin Control Panel<\/h3>\r\n\r\n<p>Although we created and synced our database model, we still need to enable it for use in the admin control panel. To do this, open up <code>app\/config\/development\/config.php<\/code> and change these lines:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">Config::set('admin_models', array(\r\n\t'Users' =&gt; array('user', 'group', 'membership')\r\n);<\/pre>\r\n\r\n<p>To this:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">Config::set('admin_models', array(\r\n\t'Users' =&gt; array('user', 'group', 'membership'),\r\n\t'Gallery' =&gt; array('photo')\r\n);<\/pre>\r\n\r\n<p>That's all it takes! Now you can open up <code>http:\/\/localhost\/path\/to\/app\/admin<\/code> and start uploading photos. Of course there are many more options that can be set to configure the admin, but I won't show any of those here. For now here are some screenshots of what it looks like:<\/p>\r\n\r\n<img class=\"full\" src=\"..\/static\/tutorial\/edit.png\" \/>\r\n<img class=\"full\" src=\"..\/static\/tutorial\/list.png\" \/>\r\n<hr\/>\r\n\r\n\r\n<h3>Ordering<\/h3>\r\n\r\n<p>What we have so far is pretty good. We can add, edit, and delete photo records. However, wouldn't it be nice if we could drag-and-drop the photo records to rearrange them? Hopefully you agree, because that's the next step. To do this, we just need to add a column of <code>Order<\/code> type and tell the admin to order the list results properly:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">&lt;?php\r\n\r\nnamespace App\\Model;\r\n\r\n\/**\r\n * @option admin_order = order\r\n *\/\r\nclass Photo extends \\Core\\Model\\Base {\r\n\t\r\n\t\/**\r\n\t * @option type = Order\r\n\t *\/\r\n\tpublic $order;\r\n\r\n\t\/**\r\n\t * @option type = Image\r\n\t * @option required = Image field is required.\r\n\t *\/\r\n\tpublic $image;\r\n\r\n\t\/**\r\n\t * @option type = Varchar\r\n\t * @option length = 100\r\n\t * @option required = Title field is required.\r\n\t *\/\r\n\tpublic $title;\r\n\r\n\t\/**\r\n\t * @option type = Text\r\n\t *\/\r\n\tpublic $description;\r\n\r\n\t\/**\r\n\t * Image Path\r\n\t * @return string\r\n\t *\/\r\n\tpublic function image_path() {\r\n\r\n\t\treturn \"static\/photo\/{$this->id}\";\r\n\r\n\t}\r\n\r\n}<\/pre>\r\n\r\n<p>Sync the model (drop then create), delete any old uploaded image files, and then you should be able to arrange photo records however you like.<\/p>\r\n\r\n<img class=\"full\" src=\"..\/static\/tutorial\/drag.png\" \/>\r\n<hr\/>\r\n\r\n\r\n<h3>User Interface<\/h3>\r\n\r\n<p>To puts things in the simplest of terms, Burner is basically a MVC framework with an admin control panel. Once you are done defining models and setting up the admin, then you create controllers and templates to display web pages. Don't worry though, Burner has a great API which makes this all very easy for any experienced developer.<\/p>\r\n\r\n<p>Now that we have a system in place to manage photos, the next step is to setup a couple pages to show off our photos to the rest of the world. The first thing that we need to do is create a controller, so make a file located at <code>app\/controller\/photo.php<\/code> with the following content:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">&lt;?php\r\n\r\nnamespace App\\Controller;\r\n\r\nclass Photo extends \\Core\\Controller\\Base {\r\n\t\r\n\tpublic function index() {\r\n\r\n\t\t$photos = \\App\\Model\\Photo::select()->order_asc('order')->fetch();\r\n\t\t$this->data('photos', $photos);\r\n\r\n\t}\r\n\r\n\tpublic function view($id) {\r\n\r\n\t\t$photo = \\App\\Model\\Photo::id($id) or $this->error('404');\r\n\t\t$this->data('photo', $photo);\r\n\r\n\t}\r\n\r\n}<\/pre>\r\n\r\n<p>Next, we have to hook these two controller methods up to Burner's URL router. This will tell Burner to use these controller methods when certain URLs are visited in the web browser. Open up <code>app\/config\/route.php<\/code> and add this to the top of the file:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">Route::add('app.controller.photo', array(\r\n\r\n\t'GET:\/' =&gt; 'index',\r\n\t'GET:photo\/:int' =&gt; 'view'\r\n\r\n));<\/pre>\r\n\r\n<p>Lastly, we have to create the template files, which display content to the screen. Make <code>app\/template\/base.php<\/code> with this content:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n\t&lt;head&gt;\r\n\t\t&lt;title&gt;Photo Gallery&lt;\/title&gt;\r\n\t&lt;\/head&gt;\r\n\t&lt;body&gt;\r\n\t\t&lt;?php $this-&gt;section('content'); ?&gt;\r\n\t\t\t\r\n\t\t\t&lt;!-- Default Content --&gt;\r\n\t\t\t\r\n\t\t&lt;?php $this-&gt;end_section(); ?&gt;\r\n\t&lt;\/body&gt;\r\n&lt;\/html&gt;<\/pre>\r\n\r\n<p>This is the base template. Our other template files will extend this template, so that we don't have to repeat the header and footer code in every template. Now create the <code>app\/template\/photo\/index.php<\/code> template:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">&lt;?php $this-&gt;base('base'); ?&gt;\r\n\r\n\r\n&lt;!-- Main Content --&gt;\r\n&lt;?php $this-&gt;extend('content'); ?&gt;\r\n\r\n\t&lt;h1&gt;Photos&lt;\/h1&gt;\r\n\r\n\t&lt;?php if(empty($photos)): ?&gt;\r\n\r\n\t\t&lt;p&gt;No photos to display.&lt;\/p&gt;\r\n\r\n\t&lt;?php else: ?&gt;\r\n\r\n\t\t&lt;ul&gt;\r\n\r\n\t\t\t&lt;?php foreach($photos as $photo): ?&gt;\r\n\r\n\t\t\t\t&lt;li&gt;\r\n\t\t\t\t\t&lt;a href=\"&lt;?= url(\"photo\/{$photo-&gt;id}\"); ?&gt;\"&gt;\r\n\t\t\t\t\t\t&lt;img width=\"100\" src=\"&lt;?= $photo-&gt;image_url(); ?&gt;\" \/&gt;\r\n\t\t\t\t\t&lt;\/a&gt;\r\n\t\t\t\t&lt;\/li&gt;\r\n\r\n\t\t\t&lt;?php endforeach; ?&gt;\r\n\r\n\t\t&lt;\/ul&gt;\r\n\r\n\t&lt;?php endif; ?&gt;\r\n\t\r\n&lt;?php $this-&gt;end_extend(); ?&gt;<\/pre>\r\n\r\n<p>Finally, create <code>app\/template\/photo\/view.php<\/code>:<\/p>\r\n\r\n<pre class=\"prettyprint lang-xml\">&lt;?php $this-&gt;base('base'); ?&gt;\r\n\r\n\r\n&lt;!-- Main Content --&gt;\r\n&lt;?php $this-&gt;extend('content'); ?&gt;\r\n\r\n\t&lt;h1&gt;&lt;?= e($photo-&gt;title); ?&gt;&lt;\/h1&gt;\r\n\r\n\t&lt;?php if(!empty($photo-&gt;description)): ?&gt;\r\n\r\n\t\t&lt;p&gt;&lt;?= e($photo-&gt;description); ?&gt;&lt;\/p&gt;\r\n\r\n\t&lt;?php endif; ?&gt;\r\n\r\n\t&lt;img src=\"&lt;?= $photo-&gt;image_url(); ?&gt;\" \/&gt;\r\n\t\r\n&lt;?php $this-&gt;end_extend(); ?&gt;<\/pre>\r\n\r\n<p>Now you can open up your web browser to <code>http:\/\/localhost\/path\/to\/app<\/code> and explore your website!<\/p>\r\n\r\n<p><b>Notes:<\/b> Burner uses the controller class name and controller method name to determine which template is loaded, the <code>e()<\/code> function that's used in the templates escapes HTML content, and <code>url()<\/code> generates full URLs to pages and static resources in your app.<\/p>\r\n\r\n<img class=\"full\" src=\"..\/static\/tutorial\/index.png\" \/>\r\n<img class=\"full\" src=\"..\/static\/tutorial\/view.png\" \/>\r\n<hr\/>\r\n\r\n\r\n<h3>Categories<\/h3>\r\n\r\n<p>Let's take this application another step forward and add categories for our photos. Burner handles relationships between models really well, so this will be a breeze. The first thing to do is create the category model, so create <code>app\/model\/category.php<\/code> and place the following code in it:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">&lt;?php\r\n\r\nnamespace App\\Model;\r\n\r\nclass Category extends \\Core\\Model\\Base {\r\n\t\r\n\t\/**\r\n\t * @option type = Varchar\r\n\t * @option length = 100\r\n\t * @option required = Name field is required.\r\n\t *\/\r\n\tpublic $name;\r\n\r\n\t\/**\r\n\t * @option type = HasMany\r\n\t * @option model = Photo\r\n\t * @option column = category\r\n\t *\/\r\n\tpublic $photos;\r\n\r\n\t\/**\r\n\t * To String\r\n\t * @return String\r\n\t *\/\r\n\tpublic function __toString() {\r\n\r\n\t\treturn $this-&gt;name;\r\n\r\n\t}\r\n\r\n}<\/pre>\r\n\r\n<p>Quickly take notice of the <code>__toString()<\/code> method. This method is important, because it tells the admin how to represent Category objects when they are echoed to the screen. As you will see later, this is done when they are displayed inside of HTML select boxes.<\/p>\r\n\r\n<p>However, more importantly, this model has a couple fields: name and photos. The photos field is a <code>HasMany<\/code>, which references the <code>category<\/code> column on the <code>Photo<\/code> model. Basically, this means that each category has many photos. The only issue with this is that the Photo model doesn't have a <code>category<\/code> column, so let's add it:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">&lt;?php\r\n\r\nnamespace App\\Model;\r\n\r\n\/**\r\n * @option admin_order = order\r\n *\/\r\nclass Photo extends \\Core\\Model\\Base {\r\n\t\r\n\t\/**\r\n\t * @option type = Order\r\n\t *\/\r\n\tpublic $order;\r\n\r\n\t\/**\r\n\t * @option type = Image\r\n\t * @option required = Image field is required.\r\n\t *\/\r\n\tpublic $image;\r\n\r\n\t\/**\r\n\t * @option type = BelongsTo\r\n\t * @option required = Category field is required.\r\n\t *\/\r\n\tpublic $category;\r\n\r\n\t\/**\r\n\t * @option type = Varchar\r\n\t * @option length = 100\r\n\t * @option required = Title field is required.\r\n\t *\/\r\n\tpublic $title;\r\n\r\n\t\/**\r\n\t * @option type = Text\r\n\t *\/\r\n\tpublic $description;\r\n\r\n\t\/**\r\n\t * Image Path\r\n\t * @return string\r\n\t *\/\r\n\tpublic function image_path() {\r\n\r\n\t\treturn \"static\/photo\/{$this->id}\";\r\n\r\n\t}\r\n\r\n}<\/pre>\r\n\r\n<p>The <code>BelongsTo<\/code> column type is basically the reverse of <code>HasMany<\/code>. Then create both of the tables by running the <code>php index.php sync photo category<\/code> command. The last thing to do is enable the category model in the admin:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">Config::set('admin_models', array(\r\n\t'Users' =&gt; array('user', 'group', 'membership'),\r\n\t'Gallery' =&gt; array('category', 'photo')\r\n);<\/pre>\r\n\r\n<p>Now categories can be managed in the admin control panel:<\/p>\r\n\r\n<img class=\"full\" src=\"..\/static\/tutorial\/category-list.png\" \/>\r\n<img class=\"full\" src=\"..\/static\/tutorial\/category-edit.png\" \/>\r\n\r\n<p>Additionally, categories can be added via the photo add\/edit pages:<\/p>\r\n\r\n<img class=\"full\" src=\"..\/static\/tutorial\/category-inline1.png\" \/>\r\n<img class=\"full\" src=\"..\/static\/tutorial\/category-inline2.png\" \/>\r\n\r\n<p>Now just update the controller and view template to display the category.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">&lt;?php\r\n\r\nnamespace App\\Controller;\r\n\r\nclass Photo extends \\Core\\Controller\\Base {\r\n\t\r\n\tpublic function index() {\r\n\r\n\t\t$photos = \\App\\Model\\Photo::select()-&gt;order_asc('order')-&gt;fetch();\r\n\t\t$this-&gt;data('photos', $photos);\r\n\r\n\t}\r\n\r\n\tpublic function view($id) {\r\n\r\n\t\t$photo = \\App\\Model\\Photo::id($id) or $this-&gt;error('404');\r\n\t\t$category = \\App\\Model\\Category::id($photo-&gt;category);\r\n\t\t$this-&gt;data('photo', $photo);\r\n\t\t$this-&gt;data('category', $category);\r\n\r\n\t}\r\n\r\n}<\/pre>\r\n\r\n<pre class=\"prettyprint lang-xml\">&lt;?php $this-&gt;base('base'); ?&gt;\r\n\r\n\r\n&lt;!-- Main Content --&gt;\r\n&lt;?php $this-&gt;extend('content'); ?&gt;\r\n\r\n\t&lt;h1&gt;&lt;?= e($photo-&gt;title); ?&gt;&lt;\/h1&gt;\r\n\t&lt;p&gt;Posted in &lt;?= e($category-&gt;name); ?&gt;&lt;\/p&gt;\r\n\r\n\t&lt;?php if(!empty($photo-&gt;description)): ?&gt;\r\n\r\n\t\t&lt;p&gt;&lt;?= e($photo-&gt;description); ?&gt;&lt;\/p&gt;\r\n\r\n\t&lt;?php endif; ?&gt;\r\n\r\n\t&lt;img src=\"&lt;?= $photo-&gt;image_url(); ?&gt;\" \/&gt;\r\n\t\r\n&lt;?php $this-&gt;end_extend(); ?&gt;<\/pre>\r\n\r\n<p>There you have it! I hope this gave you a nice and quick overview of how to create a simple application with Burner.<\/p>"},{"id":"28","order":"6","guidecategory":"2","title":"Model Admin Options","url":"model-admin","content":"<p>Every Burner CMS model can be configured to be manageable in the admin. Here's a list of all the different configuration options related to the admin control panel.<\/p>\r\n\r\n<ul>\r\n<li>&bull; <a href=\"#list\">List<\/a><\/li>\r\n<li>&bull; <a href=\"#order\">Order<\/a><\/li>\r\n<li>&bull; <a href=\"#page_size\">Page Size<\/a><\/li>\r\n<li>&bull; <a href=\"#verbose\">Verbose Name<\/a><\/li>\r\n<\/ul>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"list\">List<\/h3>\r\n<p>Specifies which columns appear in listed results. Multiple columns may be specified.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">\/**\r\n * @option admin_list = col1\r\n *\/\r\nclass Foo extends \\Core\\Model\\Base {\r\n\r\n    \/\/ ...\r\n\r\n}<\/pre>\r\n\r\n<pre class=\"prettyprint lang-php\">\/**\r\n * @option admin_list = col1, col2\r\n *\/\r\nclass Foo extends \\Core\\Model\\Base {\r\n\r\n    \/\/ ...\r\n\r\n}<\/pre>\r\n\r\n<p>Can also be applied directly to columns.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">class Foo extends \\Core\\Model\\Base {\r\n\r\n    \/\/ ...\r\n\r\n    \/**\r\n     * @option type = Text\r\n     * @option admin_list = true\r\n     *\/\r\n    public $bar;\r\n\r\n     \/**\r\n     * @option type = Password\r\n     * @option admin_list = false\r\n     *\/\r\n    public $baz;\r\n\r\n}<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"order\">Order<\/h3>\r\n<p>Used to define what order that listed results display in. Either a single column can be specified or multiple columns can be. Use the minus operator(-) to sort in descending order.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">\/**\r\n * @option admin_order = col1\r\n *\/\r\nclass Foo extends \\Core\\Model\\Base {\r\n\r\n    \/\/ ...\r\n\r\n}<\/pre>\r\n\r\n<pre class=\"prettyprint lang-php\">\/**\r\n * @option admin_order = col1, -col2, col3\r\n *\/\r\nclass Foo extends \\Core\\Model\\Base {\r\n\r\n    \/\/ ...\r\n\r\n}<\/pre>\r\n\r\n<p>Can also be applied directly to <code>BelongsTo<\/code> columns to specify which order that results appear in the select input element.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">class Foo extends \\Core\\Model\\Base {\r\n\r\n    \/\/ ...\r\n\r\n    \/**\r\n     * @option type = BelongsTo\r\n     * @option admin_order = barcol1\r\n     *\/\r\n    public $bar;\r\n\r\n}<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"page_size\">Page Size<\/h3>\r\n<p>Specifies the number of results listed per page in the admin.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">\/**\r\n * @option admin_page_size = 20\r\n *\/\r\nclass Foo extends \\Core\\Model\\Base {\r\n\r\n    \/\/ ...\r\n\r\n}<\/pre>\r\n\r\n<p>Can be set to <code>false<\/code> to specify 'infinite' page length.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">\/**\r\n * @option admin_page_size = false\r\n *\/\r\nclass Foo extends \\Core\\Model\\Base {\r\n\r\n    \/\/ ...\r\n\r\n}<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3 id=\"verbose\">Verbose Name<\/h3>\r\n<p>Used to define the human-readable name for the model. Used when displaying model name in admin headers and links.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">class Article_Comment extends \\Core\\Model\\Base {\r\n\r\n    public static $verbose = 'Article Comment';\r\n\r\n    \/\/ ...\r\n\r\n}<\/pre>\r\n\r\n<p>By default, Burner pluralizes model names by adding the 's' character to the end of its verbose name. However, this doesn't work with many words, so you are allowed to define your own plural names.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">class Category extends \\Core\\Model\\Base {\r\n\r\n    public static $verbose_plural = 'Categories';\r\n\r\n    \/\/ ...\r\n\r\n}<\/pre>\r\n\r\n<p><strong>Note:<\/strong> This is likely to change when multiple language support is completed.<\/p>"},{"id":"29","order":"5","guidecategory":"2","title":"Model Validation","url":"model-validation","content":"<p>All Burner CMS models have built-in support for easily validating the data they contain. Validation errors are displayed in the admin. Here's a model class and a basic example of validation:<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">class Article extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Email\r\n     * @option length = 100\r\n     *\/\r\n    public $author;\r\n\r\n    \/**\r\n     * @option type = Varchar\r\n     * @option length = 100\r\n     *\/\r\n    public $title;\r\n\r\n    \/**\r\n     * @option type = Text\r\n     *\/\r\n    public $content;\r\n\r\n}<\/pre>\r\n\r\n<pre class=\"prettyprint lang-php\">\/\/ Example use in a controller somewhere\r\n$article = new \\App\\Model\\Article();\r\n$errors = $article-&gt;valid();<\/pre>\r\n\r\n<p>On validation failure <code>$errors<\/code> is going to be an associative array of error messages. However, in the above example the value of <code>$errors<\/code> is going to be <code>true<\/code> because the validation passed.<\/p>\r\n<hr\/>\r\n\r\n\r\n<h3>Required Columns<\/h3>\r\n<p>By default all columns are optional. To make a column required add the <code>required<\/code> option to its doc comment.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">class Article extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Email\r\n     * @option length = 100\r\n     * @option required = Email field is required.\r\n     *\/\r\n    public $author;\r\n\r\n    \/**\r\n     * @option type = Varchar\r\n     * @option length = 100\r\n     * @option required = Title field is required.\r\n     *\/\r\n    public $title;\r\n\r\n    \/**\r\n     * @option type = Text\r\n     *\/\r\n    public $content;\r\n\r\n}<\/pre>\r\n\r\n<p>Now when <code>valid()<\/code> is run the <code>$errors<\/code> variable should contain an associative array with two errors. When both fields are populated then the result of <code>valid()<\/code> will be true.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$article = new \\App\\Model\\Article();\r\n$errors = $article-&gt;valid();\r\n\r\n\/\/ $errors == array (\r\n\/\/    'author' =&gt; 'Email field is required.',\r\n\/\/    'title' =&gt; 'Title field is required.'\r\n\/\/ )\r\n\r\n$article-&gt;author = 'some_invalid_email';\r\n$article-&gt;title = 'Awesome Article!';\r\n$errors = $article-&gt;valid();\r\n\r\n\/\/ $errors == array (\r\n\/\/    'author' =&gt; 'Invalid email address.',\r\n\/\/ )\r\n\r\n$article-&gt;author = 'foo@bar.com';\r\n$errors = $article-&gt;valid();\r\n\r\n\/\/ $errors === true<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3>Unique Columns<\/h3>\r\n<p>Unique constraints can be applied to columns to ensure that duplicate data doesn't exist in the database.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">class Article extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Email\r\n     * @option length = 100\r\n     * @option required = Email field is required.\r\n     *\/\r\n    public $author;\r\n\r\n    \/**\r\n     * @option type = Varchar\r\n     * @option length = 100\r\n     * @option required = Title field is required.\r\n     * @option unique = Title already in use.\r\n     *\/\r\n    public $title;\r\n\r\n    \/**\r\n     * @option type = Text\r\n     *\/\r\n    public $content;\r\n\r\n}<\/pre>\r\n\r\n<p>Validation should now fail when trying to add an article with a title that already exists.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$article = new \\App\\Model\\Article();\r\n\r\n$article-&gt;author = 'foo@bar.com';\r\n$article-&gt;title = 'Some Already Used Title!';\r\n$errors = $article-&gt;valid();\r\n\r\n\/\/ $errors == array (\r\n\/\/    'author' =&gt; 'Title already in use.',\r\n\/\/ )\r\n\r\n$article-&gt;title = 'Some Unique Title!';\r\n$errors = $article-&gt;valid();\r\n\r\n\/\/ $errors === true<\/pre>\r\n<hr\/>\r\n\r\n\r\n<h3>Custom Validation<\/h3>\r\n<p>Custom rules can be added via validation methods.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">class Article extends \\Core\\Model\\Base {\r\n\r\n    \/**\r\n     * @option type = Email\r\n     * @option length = 100\r\n     * @option required = Email field is required.\r\n     *\/\r\n    public $author;\r\n\r\n    \/**\r\n     * @option type = Varchar\r\n     * @option length = 100\r\n     * @option required = Title field is required.\r\n     * @option unique = Title already in use.\r\n     *\/\r\n    public $title;\r\n\r\n    \/**\r\n     * @option type = Text\r\n     *\/\r\n    public $content;\r\n\r\n    \/**\r\n     * Title Validator\r\n     *\/\r\n    public function title_validator() {\r\n\r\n        if(strlen($this-&gt;title) &lt; 5) {\r\n\r\n            return 'Title must be at least five characters long.';\r\n\r\n        }\r\n\r\n        return true;\r\n\r\n    } \r\n\r\n}<\/pre>\r\n\r\n<p>Validator methods should return <code>true<\/code> on success and a string on failure.<\/p>\r\n<p><strong>Note:<\/strong> The doc comment on the validator method is not required.<\/p>\r\n\r\n<pre class=\"prettyprint lang-php\">$article = new \\App\\Model\\Article();\r\n\r\n$article-&gt;author = 'foo@bar.com';\r\n$article-&gt;title = 'Hi!';\r\n$errors = $article-&gt;valid();\r\n\r\n\/\/ $errors == array (\r\n\/\/    'author' =&gt; 'Title must be at least five characters long.',\r\n\/\/ )\r\n\r\n$article-&gt;title = 'Some Longer Title!';\r\n$errors = $article-&gt;valid();\r\n\r\n\/\/ $errors === true<\/pre>\r\n\r\n<p><strong>Note:<\/strong> The validation syntax is likely to slightly change when multiple language support is completed.<\/p>"}]